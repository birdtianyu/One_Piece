### 1. 插入排序      worst case: O($n^2$)


---

![插入排序](D:\技法\笔记图片\插入排序.png)

### 2. 希尔排序     worst case: O($n^2$) or O($n^{\frac{3}{2} }$)

---

希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O($n^2$)的第一批算法之一。

![希尔排序](D:\技法\笔记图片\希尔排序.png)

### 3. 堆排序      best, average, worst case: O($n\log{n}$)

---

**堆**

　　堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为**大顶堆**；或者每个结点的值都小于或等于其左右孩子结点的值，称为**小顶堆**。

![堆](D:\技法\笔记图片\堆.png)

<img src="D:\技法\笔记图片\大顶堆数组.png" alt="大顶堆数组" style="zoom: 33%;" />

**大顶堆：** arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2] 

**小顶堆：** arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]  



**A: 从数组构建大顶堆**

<img src="D:\技法\笔记图片\构建堆1.png" alt="构建堆1" style="zoom:67%;" />

<img src="D:\技法\笔记图片\构建大根堆2.png" alt="构建大根堆2" style="zoom:67%;" />

<img src="D:\技法\笔记图片\构建大根堆3.png" alt="构建大根堆3" style="zoom:67%;" />

<img src="D:\技法\笔记图片\构建大根堆4.png" alt="构建大根堆4" style="zoom:67%;" />

<img src="D:\技法\笔记图片\构建大根堆5.png" alt="构建大根堆5" style="zoom:67%;" />



**B:从大顶堆构建小顶堆**

将顶端的数与最后一位数交换，然后将剩余的数再构造成一个**大根堆**。

<img src="D:\技法\笔记图片\构建小顶堆2.png" alt="构建小顶堆2" style="zoom:67%;" />

<img src="D:\技法\笔记图片\构建小顶堆3.png" alt="构建小顶堆4" style="zoom:67%;" />

<img src="D:\技法\笔记图片\构建小顶堆4.png" alt="构建小顶堆3" style="zoom:67%;" />

<img src="D:\技法\笔记图片\构建小顶堆5.png" alt="构建小顶堆5" style="zoom:67%;" />

### 4. 归并排序    best, average, worst case: O($n\log{n}$)

---

归并排序（**merge sort**）是利用**归并**的思想实现的排序方法，该算法采用经典的**分治**（divide-and-conquer）策略（分治法将问题**分**(divide)成一些小的问题然后递归求解，而**治(conquer)**的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。

![分制](D:\技法\笔记图片\分制.png)

![归并排序1](D:\技法\笔记图片\归并排序1.png)

![归并排序2](D:\技法\笔记图片\归并排序2.png)

### 5. 快速排序    average case: O($n\log{n}$)    worst case: O($n^2$) 

---

通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

**算法流程：**

在快排的过程中，每一次我们要取一个元素作为枢纽值，以这个数字来将序列划分为两部分。在此我们采用三数取中法，也就是取左端、中间、右端三个数，然后进行排序，将中间数作为枢纽值。**(※ 不用取三个，比如只取最右边的值当标志也可以，重点在于标志放到分好的位置即可)**

<img src="D:\技法\笔记图片\快排1.png" alt="快排1" style="zoom: 50%;" />

<img src="D:\技法\笔记图片\快排2.png" alt="快排2" style="zoom:67%;" />

<img src="D:\技法\笔记图片\快排3.png" alt="快排3" style="zoom:67%;" />

### 6. 计数排序     average, worst case: O($n+k$)

---

假设要排序的数字范围确定，比如[0, k], 只需要做一个k长的数组，统计每个数字出现的次数即可。



### 7. 基数排序 (radix sort)    average, worst case: O($d(n+k)$) 

---

假设对n个d位数字排序，依个位，十位，百位进行计数排序即可。 **※ 从低位到高位**



### 8. 桶排序 (bucket sort)    average: O($n$)  worst case: O($n^2$) 

----

假设数据的值分布均匀， 将数值区间划分出n个等距区间(bucket)，对每个bucket进行插入排序后，合并。

（不一定是均匀分布）



